'''
https://www.acmicpc.net/problem/5525 - IOIOI

소요시간 11분, 풀이 50점, 100점풀이는 구글링해서 참조함

아이디어 : IOI의 반복 수를 확인해서 목표 수에 다다르면 카운트한 후
           앞에서부터 하나씩 제거하는 방법을 써서 부분적으로 확인함

시간복잡도 : O(N)

자료구조 : 

느낀점 : 파이썬의 스트링 슬라이싱은 O(b-a) 시간이 든다고 함.
         그래서 첫 번째 풀이법은 O(N*(b-a))의 시간이 들어서
         시간초과가 나는 것이었음
'''

import sys

N = int(sys.stdin.readline())
M = int(sys.stdin.readline())
S = sys.stdin.readline().strip()

t = "IOI"
cnt, i, ans = 0, 0, 0

while i < M-1: # 문자열의 길이만큼 반복

    if S[i:i+3] == t: # 현재부터 앞으로 나올 2개의 문자가 IOI라면
        i += 2 # 현재에서 2칸 건너뜀 (IOI가 맞으니 뒤에 또 OI가 반복되는지 알아봐야함)
        cnt += 1 # IOI 세트의 개수에 1을 추가함

        if cnt == N: # 현재까지 찾은 IOI의 세트가 목표했던 개수와 같다면 해당 문자열을 찾은 것임
            ans += 1 # 문자열을 찾았으므로 정답에 1 더함
            cnt -= 1 # IOI 세트에서 1개씩 건너뛰어서 왔으므로 뒤에 OI가 반복될 수 있으므로 하나 뺌
                     # 현재 찾은 값의 부분이 새로운 목표를 찾을 수 있는 경우를 고려한 것
    
    else: # 지금 확인한 3개의 문자열이 IOI가 아니면
        i += 1 # 다음 칸의 문자열 확인
        cnt = 0 # 문자열이 아니니 카운트는 0

print(ans)