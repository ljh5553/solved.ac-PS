'''
https://www.acmicpc.net/problem/17070 - 파이프 옮기기 1

소요시간 36분, 풀이실패, 구글링으로 해설 공부 후 구현

아이디어 : DP. 가로 세로 대각선 파이프에 대한 2차원 DP리스트를 만든 뒤, 각 지점에서 각 파이프가 가능한 경우의 수를 기록
           이후 목표지점에서 세 파이프에 대한 경우의 수를 모두 더해 출력

시간복잡도 : 

자료구조 : 

느낀점 : 처음에는 길을 찾는 경우의 수였으므로 DFS로 구현하려다 실패했다
         풀이를 찾아보니 DFS BFS도 가능하지만 파이썬은 시간초과가 난다고 해서 DP 풀이법으로 구현해 제출함

         가로 세로 대각선이라는 3가지 경우의 수가 있으므로 각 경우의 수가 어디서부터 나오는지 파악하고
         3가지로 분기를 나누어서 풀면 된다
         나는 처음에 현재 놓인 파이프의 상태를 토대로 다시 분기를 내려고 하니 코드가 지나치게 복잡하고 길어짐
'''

import sys
    
N = int(sys.stdin.readline())
matrix = []
for _ in range(N):
    matrix.append(list(map(int, sys.stdin.readline().split())))

# dp[0] -> 가로 파이프의 DP, dp[1] -> 세로 파이프의 DP, dp[2] -> 대각 파이프의 DP
dp = [[[0 for _ in range(N)] for _ in range(N)] for _ in range(3)]

dp[0][0][1] = 1 # 0,1에 놓을 수 있는 가로파이프는 1개 (시작지점)
for i in range(2, N): # 0행에서 가로파이프 경우의 수는 무조건 1이다 (직선으로만 올 수 있으니까)
    if matrix[0][i] == 1: break # 만약 직선상에 벽이 있으면 더 못 놓으니 break
    dp[0][0][i] = 1 # 벽이 없다면 무조건 경우의 수는 1

for i in range(1, N):
    for j in range(1, N):
         # 대각선 파이프를 놓을 수 있으면
        if matrix[i][j] == 0 and matrix[i-1][j] == 0 and matrix[i][j-1] == 0:
            # 대각선 파이프 경우의 수는 가로세로대각선의 좌상단에서 오는 수
            dp[2][i][j] = dp[0][i-1][j-1] + dp[1][i-1][j-1] + dp[2][i-1][j-1]
        
        # 가로세로 파이프를 놓을 수 있으면
        if matrix[i][j] == 0:
            # 가로 파이프 경우의 수는 왼쪽에서 오는 수
            dp[0][i][j] = dp[0][i][j-1] + dp[2][i][j-1]
            # 세로 파이프 경우의 수는 위에서 오는 수
            dp[1][i][j] = dp[1][i-1][j] + dp[2][i-1][j]

# 가로 세로 대각선의 모든 파이프 경우의 수를 더하면 정답
print(dp[0][-1][-1] + dp[1][-1][-1] + dp[2][-1][-1])