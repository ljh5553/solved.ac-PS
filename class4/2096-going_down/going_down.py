'''
https://www.acmicpc.net/problem/2096 - 내려가기

소요시간 21분, 풀이실패(DP로 풀었으나 메모리 초과), 구글링으로 슬라이딩 윈도우 기법 학습

아이디어 : DP. DP[i][j]의 값은 j가 0일 때는 i-1,(0,1)에서 가져오면 되고 j가 1일 때는 i-1,(0,1,2)...
           이런 느낌으로 바로 위와 대각선 위의 왼쪽오른쪽에서 최대 및 최소값을 가져와 계산한다

시간복잡도 : 

자료구조 : DP를 저장할 2차원리스트가 있으나 단순히 지금까지의 값들을 전부 저장하는 것이 아닌
           DP의 0번행에는 그 시점의 최대값을, 1번행에는 최소값을 저장해서
           주어진 숫자 행렬의 한 행마다 그 때의 최소 및 최대를 갱신해준다
           이를 슬라이딩 윈도우라고 하는듯 (투포인터에도 슬라이딩 윈도우 개념이 있어서 주의해야함)

느낀점 : 메모리제한이 4MB라는 것을 봤으나, 최대 30만개의 int가 들어가는 배열 3개이므로
         결론적으로 메모리 소요는 약 3.6MB라고 생각해 풀었지만 메모리 초과로 실패했다

         사실 해결법은 간단했는데 결국 과정이 필요한게 아니라 결과값만 필요한 것이므로
         정수 6개만 저장하는 배열을 만들어 3개는 지금까지의 최대, 3개는 지금까지의 최소만
         단순하게 저장해서 풀면 되는 것이였다

         4MB의 메모리는 내 생각대로 단순히 산출한 값보다 훨씬 빡빡한 것 같다
'''

import sys

N = int(sys.stdin.readline())
matrix = []

dp = [[0 for _ in range(3)] for _ in range(2)]

nums = list(map(int, sys.stdin.readline().split()))
dp = [[nums[0], nums[1], nums[2]], [nums[0], nums[1], nums[2]]]

for _ in range(N-1):
    nums = list(map(int, sys.stdin.readline().split()))
    dp = [[max(dp[0][0], dp[0][1]) + nums[0], max(dp[0][0], dp[0][1], dp[0][2]) + nums[1], max(dp[0][1], dp[0][2]) + nums[2]],
            [min(dp[1][0], dp[1][1]) + nums[0], min(dp[1][0], dp[1][1], dp[1][2]) + nums[1], min(dp[1][1], dp[1][2]) + nums[2]]]
    
print(max(dp[0]), min(dp[1]))